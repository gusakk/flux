[{"path":"array","name":"array","doc":"","values":[{"pkgpath":"array","name":"from","doc":"<p>from will construct a table from the input rows.</p>\n<p>This function takes the <code>rows</code> parameter. The rows\nparameter is an array of records that will be constructed.\nAll of the records must have the same keys and the same types\nfor the values.</p>\n<p>Example:</p>\n<pre><code>import &quot;array&quot;\narray.from(rows:[{a:1, b: false, c: &quot;hi&quot;}, {a:2, b: true, c: &quot;bye&quot;}])\n</code></pre>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"contrib/RohanSreerama5/naiveBayesClassifier","name":"naiveBayesClassifier","doc":"<p>Final working code as of August 11, 2020\nCurrently supports single field classification and binary data sets\nPlease ensure Ruby is installed</p>\n","values":[]},{"path":"contrib/anaisdg/anomalydetection","name":"anomalydetection","doc":"","values":[]},{"path":"contrib/anaisdg/statsmodels","name":"statsmodels","doc":"","values":[]},{"path":"contrib/bonitoo-io/alerta","name":"alerta","doc":"","values":[]},{"path":"contrib/bonitoo-io/tickscript","name":"tickscript","doc":"","values":[{"pkgpath":"contrib/bonitoo-io/tickscript","name":"join","doc":"<p>join merges two streams using standard join().\nIt is meant a convenience function, it ensures _measurement column exists and is in the group key.</p>\n","typ":"(<-tables:A, ?method:string, ?on:[string]) => [B] where A: Record, B: Record"}]},{"path":"contrib/bonitoo-io/victorops","name":"victorops","doc":"","values":[]},{"path":"contrib/bonitoo-io/zenoss","name":"zenoss","doc":"","values":[]},{"path":"contrib/chobbs/discord","name":"discord","doc":"","values":[]},{"path":"contrib/jsternberg/aggregate","name":"aggregate","doc":"","values":[{"pkgpath":"contrib/jsternberg/aggregate","name":"window","doc":"<p>window will aggregate columns and create tables by\norganizing incoming points into windows.</p>\n<p>Each table will have two additional columns: start and stop.\nThese are the start and stop times for each interval.\nIt is not possible to use start or stop as destination column\nnames with this function. The start and stop columns are not\nadded to the group key.</p>\n<p>The same options as for table apply to window.\nIn addition to those options, window requires one\nadditional parameter.\nevery = duration\nThe duration between the start of each interval.</p>\n<p>Along with the above required option, there are a few additional\noptional parameters.\ntime = string\nThe column name for the time input.\nThis defaults to _time or time, whichever is earlier in\nthe list of columns.\nperiod = duration\nThe length of the interval. This defaults to the\nevery duration.</p>\n","typ":"(<-tables:[A], ?createEmpty:bool, ?every:duration, ?offset:duration, ?period:duration, ?startColumn:string, ?stopColumn:string, ?timeColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"contrib/jsternberg/aggregate","name":"min","doc":"<p>min constructs a min aggregate or selector for the column.</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"contrib/jsternberg/aggregate","name":"max","doc":"<p>max constructs a max aggregate or selector for the column.</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"contrib/jsternberg/aggregate","name":"sum","doc":"<p>sum constructs a sum aggregate for the column.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"contrib/jsternberg/aggregate","name":"count","doc":"<p>count constructs a count aggregate for the column.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"contrib/jsternberg/aggregate","name":"mean","doc":"<p>mean constructs a mean aggregate for the column.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"}]},{"path":"contrib/jsternberg/influxdb","name":"influxdb","doc":"","values":[{"pkgpath":"contrib/jsternberg/influxdb","name":"from","doc":"<p>from will retrieve data from a bucket between the start and stop time.\nThis version of from is the equivalent of doing from |&gt; range\nas a single call.</p>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"contrib/jsternberg/math","name":"math","doc":"","values":[{"pkgpath":"contrib/jsternberg/math","name":"min","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"contrib/jsternberg/math","name":"max","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"contrib/jsternberg/math","name":"sum","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"}]},{"path":"contrib/jsternberg/rows","name":"rows","doc":"","values":[{"pkgpath":"contrib/jsternberg/rows","name":"map","doc":"<p>map will map each of the rows to a new value.\nThe function will be invoked for each row and the\nreturn value will be used as the values in the output\nrow.</p>\n<p>The record that is passed to the function will contain\nall of the keys and values in the record including group\nkeys, but the group key cannot be changed. Attempts to\nchange the group key will be ignored.</p>\n<p>The returned record does not need to contain values that are\npart of the group key.</p>\n","typ":"(<-tables:[A], fn:(r:A) => B, ?mergeKey:bool) => [B]"}]},{"path":"contrib/rhajek/bigpanda","name":"bigpanda","doc":"","values":[]},{"path":"contrib/sranka/opsgenie","name":"opsgenie","doc":"","values":[]},{"path":"contrib/sranka/sensu","name":"sensu","doc":"","values":[]},{"path":"contrib/sranka/teams","name":"teams","doc":"","values":[]},{"path":"contrib/sranka/telegram","name":"telegram","doc":"","values":[]},{"path":"contrib/tomhollingworth/events","name":"events","doc":"","values":[{"pkgpath":"contrib/tomhollingworth/events","name":"duration","doc":"<p>duration will calculate the duration between records\nfor each record. The duration calculated is between\nthe current record and the next. The last record will\ncompare against either the stopColum (default: _stop)\nor a stop timestamp value.</p>\n<p><code>timeColumn</code> - Optional string. Default '_time'. The value used to calculate duration\n<code>columnName</code> - Optional string. Default 'duration'. The name of the result column\n<code>stopColumn</code> - Optional string. Default '_stop'. The name of the column to compare the last record on\n<code>stop</code> - Optional Time. Use a fixed time to compare the last record against instead of stop column.</p>\n","typ":"(v:A) => duration"}]},{"path":"csv","name":"csv","doc":"<p>CSV provides an API for working with <a href=\"https://github.com/influxdata/flux/blob/master/docs/SPEC.md#csv\">annotated CSV</a> files.</p>\n","values":[{"pkgpath":"csv","name":"from","doc":"<p>From parses an annotated CSV and produces a stream of tables.</p>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"date","name":"date","doc":"","values":[]},{"path":"dict","name":"dict","doc":"","values":[]},{"path":"experimental","name":"experimental","doc":"","values":[{"pkgpath":"experimental","name":"group","doc":"<p>An experimental version of group that has mode: &quot;extend&quot;</p>\n","typ":"(<-tables:[A], ?columns:[string], ?mode:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"set","doc":"<p>set adds the values from the object onto each row of a table</p>\n","typ":"(<-tables:[A], key:string, value:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"to","doc":"<p>An experimental version of &quot;to&quot; that:</p>\n<ul>\n<li>Expects pivoted data</li>\n<li>Any column in the group key is made a tag in storage</li>\n<li>All other columns are fields</li>\n<li>An error will be thrown for incompatible data types</li>\n</ul>\n","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A] where A: Record, B: Record"},{"pkgpath":"experimental","name":"join","doc":"<p>An experimental version of join.</p>\n","typ":"(<-tables:A, ?method:string, ?on:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"window","doc":"<p>An experimental version of window.</p>\n","typ":"(<-tables:[A], ?createEmpty:bool, ?every:duration, ?offset:duration, ?period:duration, ?startColumn:string, ?stopColumn:string, ?timeColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"integral","doc":"<p>An experimental version of integral.</p>\n","typ":"(<-tables:[A], ?column:string, ?interpolate:string, ?timeColumn:string, ?unit:duration) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"count","doc":"<p>An experimental version of count.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"histogramQuantile","doc":"<p>An experimental version of histogramQuantile</p>\n","typ":"(<-tables:[A], ?countColumn:string, ?minValue:float, ?quantile:float, ?upperBoundColumn:string, ?valueColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"mean","doc":"<p>An experimental version of mean.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"mode","doc":"<p>An experimental version of mode.</p>\n","typ":"(<-tables:[A], ?column:string) => [{B with _value:C}] where A: Record, B: Record"},{"pkgpath":"experimental","name":"quantile","doc":"<p>An experimental version of quantile.</p>\n","typ":"(<-tables:[A], q:float, ?column:string, ?compression:float, ?method:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"skew","doc":"<p>An experimental version of skew.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"spread","doc":"<p>An experimental version of spread.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"stddev","doc":"<p>An experimental version of stddev.</p>\n","typ":"(<-tables:[A], ?column:string, ?mode:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"sum","doc":"<p>An experimental version of sum.</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"kaufmansAMA","doc":"<p>An experimental version of kaufmansAMA.</p>\n","typ":"(<-tables:[A], n:int, ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"distinct","doc":"<p>An experimental version of distinct</p>\n","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"experimental","name":"fill","doc":"<p>An experimental version of fill</p>\n","typ":"(<-tables:[B], ?column:string, ?usePrevious:bool, ?value:A) => [C] where B: Record, C: Record"},{"pkgpath":"experimental","name":"first","doc":"<p>An experimental version of first</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"last","doc":"<p>An experimental version of last</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"max","doc":"<p>An experimental version of max</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"min","doc":"<p>An experimental version of min</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"unique","doc":"<p>An experimental version of unique</p>\n","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"experimental","name":"histogram","doc":"<p>An experimental version of histogram</p>\n","typ":"(<-tables:[A], bins:[float], ?column:string, ?countColumn:string, ?normalize:bool, ?upperBoundColumn:string) => [B] where A: Record, B: Record"}]},{"path":"experimental/aggregate","name":"aggregate","doc":"","values":[]},{"path":"experimental/array","name":"array","doc":"","values":[{"pkgpath":"experimental/array","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"experimental/bigtable","name":"bigtable","doc":"","values":[{"pkgpath":"experimental/bigtable","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"experimental/csv","name":"csv","doc":"","values":[{"pkgpath":"experimental/csv","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"experimental/geo","name":"geo","doc":"<p>Provides functions for geographic location filtering and grouping based on S2 cells.</p>\n","values":[]},{"path":"experimental/http","name":"http","doc":"","values":[]},{"path":"experimental/influxdb","name":"influxdb","doc":"","values":[]},{"path":"experimental/json","name":"json","doc":"","values":[]},{"path":"experimental/mqtt","name":"mqtt","doc":"","values":[{"pkgpath":"experimental/mqtt","name":"to","doc":"","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A] where A: Record, B: Record"}]},{"path":"experimental/oee","name":"oee","doc":"","values":[]},{"path":"experimental/prometheus","name":"prometheus","doc":"","values":[{"pkgpath":"experimental/prometheus","name":"histogramQuantile","doc":"<p>histogramQuantile enables the user to calculate quantiles on a set of given values\nThis function assumes that the given histogram data is being scraped or read from a\nPrometheus source.</p>\n","typ":"(<-tables:[A], ?countColumn:string, ?minValue:float, ?quantile:float, ?upperBoundColumn:string, ?valueColumn:string) => [B] where A: Record, B: Record"}]},{"path":"experimental/query","name":"query","doc":"","values":[]},{"path":"experimental/table","name":"table","doc":"","values":[{"pkgpath":"experimental/table","name":"fill","doc":"<p>fill will ensure that all tables within this stream have at least\none row. If a table has no rows, one row will be created with null values\nfor every column not part of the group key.</p>\n","typ":"(<-tables:[B], ?column:string, ?usePrevious:bool, ?value:A) => [C] where B: Record, C: Record"}]},{"path":"experimental/usage","name":"usage","doc":"","values":[{"pkgpath":"experimental/usage","name":"from","doc":"<p>from returns an organization's usage data. The time range to query is\nbounded by start and stop arguments. Optional orgID, host and token arguments\nallow cross-org and/or cross-cluster queries. Setting the raw parameter will\nreturn raw usage data rather than the downsampled data returned by default.\nNote that unlike the range function, the stop argument is required here,\npending implementation of https://github.com/influxdata/flux/issues/3629.</p>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"generate","name":"generate","doc":"","values":[{"pkgpath":"generate","name":"from","doc":"<p>From generates a table with count rows using fn to determine the value of each row.</p>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"http","name":"http","doc":"","values":[]},{"path":"influxdata/influxdb","name":"influxdb","doc":"","values":[{"pkgpath":"influxdata/influxdb","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"},{"pkgpath":"influxdata/influxdb","name":"to","doc":"","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A] where A: Record, B: Record"},{"pkgpath":"influxdata/influxdb","name":"buckets","doc":"","typ":"(?host:string, ?org:string, ?orgID:string, ?token:string) => [{retentionPolicy:string, retentionPeriod:int, organizationID:string, name:string, id:string}]"},{"pkgpath":"influxdata/influxdb","name":"cardinality","doc":"<p>cardinality will return the cardinality of data for a given bucket.\nIf a predicate is specified, then the cardinality only includes series\nthat match the predicate.</p>\n","typ":"(start:A, ?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?predicate:(r:{B with _value:C, _measurement:string, _field:string}) => bool, ?stop:D, ?token:string) => [{_value:int, _stop:time, _start:time}] where A: Timeable, D: Timeable"}]},{"path":"influxdata/influxdb/monitor","name":"monitor","doc":"","values":[{"pkgpath":"influxdata/influxdb/monitor","name":"from","doc":"<p>From retrieves the check statuses that have been stored.</p>\n","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"influxdata/influxdb/schema","name":"schema","doc":"","values":[]},{"path":"influxdata/influxdb/secrets","name":"secrets","doc":"","values":[]},{"path":"influxdata/influxdb/tasks","name":"tasks","doc":"<p>Package tasks is an experimental package.\nThe API for this package is not stable and should not\nbe counted on for production code.</p>\n","values":[]},{"path":"influxdata/influxdb/v1","name":"v1","doc":"<p>V1 provides an API for working with an InfluxDB 1 instance</p>\n<blockquote>\n<p>NOTE: Must functions in this package are now deprecated see influxdata/influxdb/schema.</p>\n</blockquote>\n","values":[]},{"path":"internal/debug","name":"debug","doc":"","values":[]},{"path":"internal/gen","name":"gen","doc":"","values":[]},{"path":"internal/influxql","name":"influxql","doc":"","values":[]},{"path":"internal/promql","name":"promql","doc":"<p>THIS PACKAGE IS NOT MEANT FOR EXTERNAL USE.</p>\n","values":[{"pkgpath":"internal/promql","name":"holtWinters","doc":"<p>holtWinters() implements functionality equivalent to PromQL's holt_winters()\nfunction:</p>\n<p>https://prometheus.io/docs/prometheus/latest/querying/functions/#holt_winters</p>\n","typ":"(<-tables:[A], interval:duration, n:int, ?column:string, ?seasonality:int, ?timeColumn:string, ?withFit:bool) => [B] where A: Record, B: Record"},{"pkgpath":"internal/promql","name":"quantile","doc":"<p>quantile() accounts checks for quantile values that are out of range, above 1.0 or\nbelow 0.0, by either returning positive infinity or negative infinity in the <code>_value</code>\ncolumn respectively. q must be a float</p>\n","typ":"(<-tables:[A], q:float, ?column:string, ?compression:float, ?method:string) => [A] where A: Record"},{"pkgpath":"internal/promql","name":"join","doc":"","typ":"(<-tables:A, ?method:string, ?on:[string]) => [B] where A: Record, B: Record"}]},{"path":"internal/testutil","name":"testutil","doc":"","values":[{"pkgpath":"internal/testutil","name":"yield","doc":"","typ":"(<-tables:[A], ?name:string) => [A] where A: Record"}]},{"path":"interpolate","name":"interpolate","doc":"","values":[]},{"path":"json","name":"json","doc":"","values":[]},{"path":"kafka","name":"kafka","doc":"","values":[{"pkgpath":"kafka","name":"to","doc":"","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A] where A: Record, B: Record"}]},{"path":"math","name":"math","doc":"","values":[]},{"path":"pagerduty","name":"pagerduty","doc":"","values":[]},{"path":"planner","name":"planner","doc":"","values":[]},{"path":"profiler","name":"profiler","doc":"<p>Profiler exposes an API to profile queries.\nProfile results are returned as an extra result in the response named according to the profiles which are enabled.</p>\n","values":[]},{"path":"pushbullet","name":"pushbullet","doc":"","values":[]},{"path":"regexp","name":"regexp","doc":"","values":[]},{"path":"runtime","name":"runtime","doc":"","values":[]},{"path":"slack","name":"slack","doc":"","values":[]},{"path":"socket","name":"socket","doc":"","values":[{"pkgpath":"socket","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"}]},{"path":"sql","name":"sql","doc":"","values":[{"pkgpath":"sql","name":"from","doc":"","typ":"(?bucket:string, ?bucketID:string, ?host:string, ?org:string, ?orgID:string, ?token:string) => [{A with _value:B, _time:time, _measurement:string, _field:string}]"},{"pkgpath":"sql","name":"to","doc":"","typ":"(<-tables:[A], ?bucket:string, ?bucketID:string, ?fieldFn:(r:A) => B, ?host:string, ?measurementColumn:string, ?org:string, ?orgID:string, ?tagColumns:[string], ?timeColumn:string, ?token:string) => [A] where A: Record, B: Record"}]},{"path":"strings","name":"strings","doc":"","values":[]},{"path":"system","name":"system","doc":"","values":[{"pkgpath":"system","name":"time","doc":"","typ":"(v:A) => time"}]},{"path":"testing","name":"testing","doc":"","values":[]},{"path":"testing/expect","name":"expect","doc":"<p>Package expect includes functions to mark\nany expectations for a testcase to be satisfied\nbefore the testcase finishes running.</p>\n<p>These functions are intended to be called at the\nbeginning of a testcase, but it doesn't really\nmatter when they get invoked within the testcase.</p>\n","values":[]},{"path":"universe","name":"universe","doc":"","values":[{"pkgpath":"universe","name":"now","doc":"<p>now is a function option whose default behaviour is to return the current system time</p>\n","typ":"() => time"},{"pkgpath":"universe","name":"true","doc":"<p>Booleans</p>\n","typ":"bool"},{"pkgpath":"universe","name":"false","doc":"","typ":"bool"},{"pkgpath":"universe","name":"chandeMomentumOscillator","doc":"<p>Transformation functions</p>\n","typ":"(<-tables:[A], n:int, ?columns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"columns","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"count","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"covariance","doc":"","typ":"(<-tables:[A], columns:[string], ?pearsonr:bool, ?valueDst:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"cumulativeSum","doc":"","typ":"(<-tables:[A], ?columns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"derivative","doc":"","typ":"(<-tables:[A], ?columns:[string], ?nonNegative:bool, ?timeColumn:string, ?unit:duration) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"die","doc":"","typ":"(msg:string) => A"},{"pkgpath":"universe","name":"difference","doc":"","typ":"(<-tables:[A], ?columns:[string], ?keepFirst:bool, ?nonNegative:bool) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"distinct","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"drop","doc":"","typ":"(<-tables:[A], ?columns:[string], ?fn:(column:string) => bool) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"duplicate","doc":"","typ":"(<-tables:[A], as:string, column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"elapsed","doc":"","typ":"(<-tables:[A], ?columnName:string, ?timeColumn:string, ?unit:duration) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"exponentialMovingAverage","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:B}] where B: Numeric"},{"pkgpath":"universe","name":"fill","doc":"","typ":"(<-tables:[B], ?column:string, ?usePrevious:bool, ?value:A) => [C] where B: Record, C: Record"},{"pkgpath":"universe","name":"filter","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?onEmpty:string) => [A] where A: Record"},{"pkgpath":"universe","name":"first","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"universe","name":"group","doc":"","typ":"(<-tables:[A], ?columns:[string], ?mode:string) => [A] where A: Record"},{"pkgpath":"universe","name":"histogram","doc":"","typ":"(<-tables:[A], bins:[float], ?column:string, ?countColumn:string, ?normalize:bool, ?upperBoundColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"histogramQuantile","doc":"","typ":"(<-tables:[A], ?countColumn:string, ?minValue:float, ?quantile:float, ?upperBoundColumn:string, ?valueColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"holtWinters","doc":"","typ":"(<-tables:[A], interval:duration, n:int, ?column:string, ?seasonality:int, ?timeColumn:string, ?withFit:bool) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"hourSelection","doc":"","typ":"(<-tables:[A], start:int, stop:int, ?timeColumn:string) => [A] where A: Record"},{"pkgpath":"universe","name":"integral","doc":"","typ":"(<-tables:[A], ?column:string, ?interpolate:string, ?timeColumn:string, ?unit:duration) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"join","doc":"","typ":"(<-tables:A, ?method:string, ?on:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"kaufmansAMA","doc":"","typ":"(<-tables:[A], n:int, ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"keep","doc":"","typ":"(<-tables:[A], ?columns:[string], ?fn:(column:string) => bool) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"keyValues","doc":"","typ":"(<-tables:[A], ?keyColumns:[string]) => [{B with _value:C, _key:string}] where A: Record, B: Record"},{"pkgpath":"universe","name":"keys","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"last","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"universe","name":"limit","doc":"","typ":"(<-tables:[A], n:int, ?offset:int) => [A]"},{"pkgpath":"universe","name":"map","doc":"","typ":"(<-tables:[A], fn:(r:A) => B, ?mergeKey:bool) => [B]"},{"pkgpath":"universe","name":"max","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"universe","name":"mean","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"min","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"universe","name":"mode","doc":"","typ":"(<-tables:[A], ?column:string) => [{B with _value:C}] where A: Record, B: Record"},{"pkgpath":"universe","name":"movingAverage","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:float}] where B: Numeric"},{"pkgpath":"universe","name":"quantile","doc":"","typ":"(<-tables:[A], q:float, ?column:string, ?compression:float, ?method:string) => [A] where A: Record"},{"pkgpath":"universe","name":"pivot","doc":"","typ":"(<-tables:[A], columnKey:[string], rowKey:[string], valueColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"range","doc":"","typ":"(<-tables:[{C with _time:time}], start:A, ?stop:B) => [{C with _time:time, _stop:time, _start:time}]"},{"pkgpath":"universe","name":"reduce","doc":"","typ":"(<-tables:[B], fn:(accumulator:A, r:B) => A, identity:A) => [C] where A: Record, B: Record, C: Record"},{"pkgpath":"universe","name":"relativeStrengthIndex","doc":"","typ":"(<-tables:[A], n:int, ?columns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"rename","doc":"","typ":"(<-tables:[B], ?columns:A, ?fn:(column:string) => string) => [C] where A: Record, B: Record, C: Record"},{"pkgpath":"universe","name":"sample","doc":"","typ":"(<-tables:[A], n:int, ?column:string, ?pos:int) => [A] where A: Record"},{"pkgpath":"universe","name":"set","doc":"","typ":"(<-tables:[A], key:string, value:string) => [A] where A: Record"},{"pkgpath":"universe","name":"tail","doc":"","typ":"(<-tables:[A], n:int, ?offset:int) => [A]"},{"pkgpath":"universe","name":"timeShift","doc":"","typ":"(<-tables:[A], duration:duration, ?columns:[string]) => [A]"},{"pkgpath":"universe","name":"skew","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"spread","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"sort","doc":"","typ":"(<-tables:[A], ?columns:[string], ?desc:bool) => [A] where A: Record"},{"pkgpath":"universe","name":"stateTracking","doc":"","typ":"(<-tables:[A], fn:(r:A) => bool, ?countColumn:string, ?durationColumn:string, ?durationUnit:duration, ?timeColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"stddev","doc":"","typ":"(<-tables:[A], ?column:string, ?mode:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"sum","doc":"","typ":"(<-tables:[A], ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"tripleExponentialDerivative","doc":"","typ":"(<-tables:[{A with _value:B}], n:int) => [{A with _value:float}] where A: Record, B: Numeric"},{"pkgpath":"universe","name":"union","doc":"","typ":"(tables:[[A]]) => [A] where A: Record"},{"pkgpath":"universe","name":"unique","doc":"","typ":"(<-tables:[A], ?column:string) => [A] where A: Record"},{"pkgpath":"universe","name":"window","doc":"","typ":"(<-tables:[A], ?createEmpty:bool, ?every:duration, ?offset:duration, ?period:duration, ?startColumn:string, ?stopColumn:string, ?timeColumn:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"yield","doc":"","typ":"(<-tables:[A], ?name:string) => [A] where A: Record"},{"pkgpath":"universe","name":"tableFind","doc":"<p>stream/table index functions</p>\n","typ":"(<-tables:[B], fn:(key:A) => bool) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"getColumn","doc":"","typ":"(<-table:[A], column:string) => [B] where A: Record"},{"pkgpath":"universe","name":"getRecord","doc":"","typ":"(<-table:[A], idx:int) => A where A: Record"},{"pkgpath":"universe","name":"findColumn","doc":"","typ":"(<-tables:[B], column:string, fn:(key:A) => bool) => [C] where A: Record, B: Record"},{"pkgpath":"universe","name":"findRecord","doc":"","typ":"(<-tables:[B], fn:(key:A) => bool, idx:int) => B where A: Record, B: Record"},{"pkgpath":"universe","name":"bool","doc":"<p>type conversion functions</p>\n","typ":"(v:A) => bool"},{"pkgpath":"universe","name":"bytes","doc":"","typ":"(v:A) => bytes"},{"pkgpath":"universe","name":"duration","doc":"","typ":"(v:A) => duration"},{"pkgpath":"universe","name":"float","doc":"","typ":"(v:A) => float"},{"pkgpath":"universe","name":"int","doc":"","typ":"(v:A) => int"},{"pkgpath":"universe","name":"string","doc":"","typ":"(v:A) => string"},{"pkgpath":"universe","name":"time","doc":"","typ":"(v:A) => time"},{"pkgpath":"universe","name":"uint","doc":"","typ":"(v:A) => uint"},{"pkgpath":"universe","name":"contains","doc":"<p>contains function</p>\n","typ":"(set:[A], value:A) => bool where A: Nullable"},{"pkgpath":"universe","name":"inf","doc":"<p>other builtins</p>\n","typ":"duration"},{"pkgpath":"universe","name":"length","doc":"","typ":"(arr:[A]) => int"},{"pkgpath":"universe","name":"linearBins","doc":"","typ":"(count:int, start:float, width:float, ?infinity:bool) => [float]"},{"pkgpath":"universe","name":"logarithmicBins","doc":"","typ":"(count:int, factor:float, start:float, ?infinity:bool) => [float]"},{"pkgpath":"universe","name":"sleep","doc":"<p>sleep is the identity function with the side effect of delaying execution by a specified duration</p>\n","typ":"(<-v:A, duration:duration) => A"},{"pkgpath":"universe","name":"die","doc":"<p>die returns a fatal error from within a flux script</p>\n","typ":"(msg:string) => A"},{"pkgpath":"universe","name":"timeWeightedAvg","doc":"<p>Time weighted average where values at the beginning and end of the range are linearly interpolated.</p>\n","typ":"(<-tables:[A], unit:duration) => [{B with _value:float, _value:float, _stop:D, _start:C}] where A: Record"},{"pkgpath":"universe","name":"cov","doc":"<p>covariance function with automatic join</p>\n","typ":"(on:[string], x:A, y:B, ?pearsonr:bool) => [C] where C: Record"},{"pkgpath":"universe","name":"pearsonr","doc":"","typ":"(on:[string], x:A, y:B) => [C] where C: Record"},{"pkgpath":"universe","name":"aggregateWindow","doc":"<p>AggregateWindow applies an aggregate function to fixed windows of time.\nThe procedure is to window the data, perform an aggregate operation,\nand then undo the windowing to produce an output table for every input table.</p>\n","typ":"(<-tables:[C], every:duration, fn:(<-:[A], column:string) => [B], ?column:string, ?createEmpty:bool, ?offset:duration, ?timeDst:string, ?timeSrc:string) => [D] where A: Record, B: Record, C: Record, D: Record"},{"pkgpath":"universe","name":"increase","doc":"<p>Increase returns the total non-negative difference between values in a table.\nA main usage case is tracking changes in counter values which may wrap over time when they hit\na threshold or are reset. In the case of a wrap/reset,\nwe can assume that the absolute delta between two points will be at least their non-negative difference.</p>\n","typ":"(<-tables:[A], ?columns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"median","doc":"<p>median returns the 50th percentile.</p>\n","typ":"(<-tables:[A], ?column:string, ?compression:float, ?method:string) => [A] where A: Record"},{"pkgpath":"universe","name":"stateCount","doc":"<p>stateCount computes the number of consecutive records in a given state.\nThe state is defined via the function fn. For each consecutive point for\nwhich the expression evaluates as true, the state count will be incremented\nWhen a point evaluates as false, the state count is reset.</p>\n<p>The state count will be added as an additional column to each record. If the\nexpression evaluates as false, the value will be -1. If the expression\ngenerates an error during evaluation, the point is discarded, and does not\naffect the state count.</p>\n","typ":"(<-tables:[A], fn:(r:A) => bool, ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"stateDuration","doc":"<p>stateDuration computes the duration of a given state.\nThe state is defined via the function fn. For each consecutive point for\nwhich the expression evaluates as true, the state duration will be\nincremented by the duration between points. When a point evaluates as false,\nthe state duration is reset.</p>\n<p>The state duration will be added as an additional column to each record. If the\nexpression evaluates as false, the value will be -1. If the expression\ngenerates an error during evaluation, the point is discarded, and does not\naffect the state duration.</p>\n<p>Note that as the first point in the given state has no previous point, its\nstate duration will be 0.</p>\n<p>The duration is represented as an integer in the units specified.</p>\n","typ":"(<-tables:[A], fn:(r:A) => bool, ?column:string, ?timeColumn:string, ?unit:duration) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"_sortLimit","doc":"<p>_sortLimit is a helper function, which sorts and limits a table.</p>\n","typ":"(<-tables:[A], desc:bool, n:int, ?columns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"top","doc":"<p>top sorts a table by columns and keeps only the top n records.</p>\n","typ":"(<-tables:[A], n:int, ?columns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"bottom","doc":"<p>top sorts a table by columns and keeps only the bottom n records.</p>\n","typ":"(<-tables:[A], n:int, ?columns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"_highestOrLowest","doc":"<p>_highestOrLowest is a helper function, which reduces all groups into a single group by specific tags and a reducer function,\nthen it selects the highest or lowest records based on the column and the _sortLimit function.\nThe default reducer assumes no reducing needs to be performed.</p>\n","typ":"(<-tables:[D], _sortLimit:(<-:[B], columns:[string], n:A) => C, n:A, reducer:(<-:[D]) => [B], ?column:string, ?groupColumns:[string]) => C where B: Record, D: Record"},{"pkgpath":"universe","name":"highestMax","doc":"<p>highestMax returns the top N records from all groups using the maximum of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"highestAverage","doc":"<p>highestAverage returns the top N records from all groups using the average of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"highestCurrent","doc":"<p>highestCurrent returns the top N records from all groups using the last value of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"lowestMin","doc":"<p>lowestMin returns the bottom N records from all groups using the minimum of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"lowestAverage","doc":"<p>lowestAverage returns the bottom N records from all groups using the average of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"lowestCurrent","doc":"<p>lowestCurrent returns the bottom N records from all groups using the last value of each group.</p>\n","typ":"(<-tables:[A], n:int, ?column:string, ?groupColumns:[string]) => [A] where A: Record"},{"pkgpath":"universe","name":"timedMovingAverage","doc":"<p>timedMovingAverage constructs a simple moving average over windows of 'period' duration\neg: A 5 year moving average would be called as such:\nmovingAverage(1y, 5y)</p>\n","typ":"(<-tables:[A], every:duration, period:duration, ?column:string) => [B] where A: Record, B: Record"},{"pkgpath":"universe","name":"doubleEMA","doc":"<p>Double Exponential Moving Average computes the double exponential moving averages of the <code>_value</code> column.\neg: A 5 point double exponential moving average would be called as such:\nfrom(bucket: &quot;telegraf/autogen&quot;):\n|&gt; range(start: -7d)\n|&gt; doubleEMA(n: 5)</p>\n","typ":"(<-tables:[{A with _value:B}], n:int) => [C] where B: Numeric, C: Record"},{"pkgpath":"universe","name":"tripleEMA","doc":"<p>Triple Exponential Moving Average computes the triple exponential moving averages of the <code>_value</code> column.\neg: A 5 point triple exponential moving average would be called as such:\nfrom(bucket: &quot;telegraf/autogen&quot;):\n|&gt; range(start: -7d)\n|&gt; tripleEMA(n: 5)</p>\n","typ":"(<-tables:[{A with _value:B}], n:int) => [C] where B: Numeric, C: Record"},{"pkgpath":"universe","name":"truncateTimeColumn","doc":"<p>truncateTimeColumn takes in a time column t and a Duration unit and truncates each value of t to the given unit via map\nChange from _time to timeColumn once Flux Issue 1122 is resolved</p>\n","typ":"(<-tables:[{A with _time:B}], unit:duration, ?timeColumn:string) => [{A with _time:B, _time:time}] where B: Timeable"},{"pkgpath":"universe","name":"kaufmansER","doc":"<p>kaufmansER computes Kaufman's Efficiency Ratios of the <code>_value</code> column</p>\n","typ":"(<-tables:[A], n:int) => [{B with _value:float, _value:float}] where A: Record"},{"pkgpath":"universe","name":"toString","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:string}]"},{"pkgpath":"universe","name":"toInt","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:int}]"},{"pkgpath":"universe","name":"toUInt","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:uint}]"},{"pkgpath":"universe","name":"toFloat","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:float}]"},{"pkgpath":"universe","name":"toBool","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:bool}]"},{"pkgpath":"universe","name":"toTime","doc":"","typ":"(<-tables:[{A with _value:B}]) => [{A with _value:B, _value:time}]"},{"pkgpath":"universe","name":"today","doc":"<p>today returns the now() timestamp truncated to the day unit</p>\n","typ":"() => time"}]}]